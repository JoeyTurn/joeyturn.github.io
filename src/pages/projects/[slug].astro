---
import BaseLayout from "../../layouts/BaseLayout.astro";
import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";

/* Accept string | Date | undefined for pubDate */
type Pub = string | Date | undefined;
function toTime(d: Pub) {
  if (!d) return 0;
  const dt = typeof d === "string" ? new Date(d) : d;
  const t = dt.getTime();
  return Number.isNaN(t) ? 0 : t;
}
function formatDate(d: Pub) {
  if (!d) return "";
  const dt = typeof d === "string" ? new Date(d) : d;
  return dt.toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" });
}

function norm(url: string) {
  return url.startsWith("http://") || url.startsWith("https://") ? url : `https://${url}`;
}

// Build-time: enumerate project pages and compute prev/next within same series.
export async function getStaticPaths() {
  const items = await getCollection("projects", ({ data }) => !data.draft);

  // group by series; items without series get unique keys to avoid paging
  const groups = new Map<string, CollectionEntry<"projects">[]>();
  for (const p of items) {
    const key = p.data.series ?? `__noseries__${p.slug}`;
    (groups.get(key) ?? groups.set(key, []).get(key)!).push(p);
  }

  const paths: Array<{
    params: { slug: string };
    props: {
      entry: CollectionEntry<"projects">;
      prev?: CollectionEntry<"projects">;
      next?: CollectionEntry<"projects">;
    };
  }> = [];

  for (const [, arr] of groups) {
    // order within series: seriesOrder (asc), then pubDate (asc), then title
    arr.sort((a, b) => {
      const ao = a.data.seriesOrder ?? toTime(a.data.pubDate);
      const bo = b.data.seriesOrder ?? toTime(b.data.pubDate);
      if (ao !== bo) return ao - bo;
      return a.data.title.localeCompare(b.data.title);
    });

    for (let i = 0; i < arr.length; i++) {
      const entry = arr[i];
      paths.push({
        params: { slug: entry.slug },
        props: { entry, prev: arr[i - 1], next: arr[i + 1] },
      });
    }
  }

  return paths;
}

// Receive the entry and neighbors
const { entry, prev, next } = Astro.props as {
  entry: CollectionEntry<"projects">;
  prev?: CollectionEntry<"projects">;
  next?: CollectionEntry<"projects">;
};

const { Content } = await entry.render();
---
<BaseLayout title={`${entry.data.title} – Projects`}>
  <h1>{entry.data.title}</h1>
  {entry.data.links && entry.data.links.length > 0 && (
  <div class="externals">
    {entry.data.links.map((L, i) => (
      <>
        <a href={norm(L.url)} target="_blank" rel="noopener noreferrer">{L.label}</a>
        {i < entry.data.links!.length - 1 && <span class="dot">·</span>}
      </>
    ))}
  </div>
)}
  {entry.data.authors && entry.data.authors.length > 0 && (
  <p class="authors">
    {entry.data.authors.map((a, i) => (
      <>
        {a.url ? (
          <a href={norm(a.url)} target="_blank" rel="noopener noreferrer">{a.name}</a>
        ) : (
          a.name
        )}
        {i < entry.data.authors!.length - 1 && <span class="sep">, </span>}
      </>
    ))}
  </p>
  )}

  {entry.data.authors?.some(a => a.name.includes("*")) && (
    <p class="author-note"><span aria-hidden="true">*</span> Joint authorship.</p>
  )}

  {entry.data.description && <p class="subtitle">{entry.data.description}</p>}
  {entry.data.pubDate && <p class="meta">{formatDate(entry.data.pubDate)}</p>}

  <Content />

  {(entry.data.series && (prev || next)) && (
    <nav class="pager" aria-label={`Series: ${entry.data.series}`}>
      <div>{prev && <a href={`/projects/${prev.slug}/`}>← {prev.data.title}</a>}</div>
      <div>{next && <a href={`/projects/${next.slug}/`}>{next.data.title} →</a>}</div>
    </nav>
  )}
</BaseLayout>

<style>
  .subtitle{ margin:.25rem 0 .5rem; font-size:1.1rem; font-weight:500; opacity:.9; }
  .authors{ margin:.25rem 0 .25rem; opacity:.85; }
  .authors a{ text-decoration: underline; }
  .authors .sep{ opacity:.6; }
  .links{ margin-top:1.25rem; }
  .links ul{ margin:.25rem 0 0 1rem; }
  .author-note { margin: .15rem 0 .5rem; font-size: .95rem; opacity: .75; }
  .pager{
    display:flex; justify-content:space-between; gap:12px;
    margin-top:40px; padding-top:16px;
    border-top:1px solid var(--rule, rgba(0,0,0,.12));
    background: transparent;
  }
</style>
